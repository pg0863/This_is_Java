상속(Inheritance)
- 자식(하위,파생) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것.
- 자식이 부모를 선택해서 물려받음.
- 상속 대상 : 부모의 필드/메소드
- 상속의 효과 : 
1. 부모 클래스를 재사용해서 자식클래스를 빨리 개발할 수 있음(코드 수 절감).
(반복된 코드의 중복을 줄여줌, 유지보수의 편리성 제공)
2. 객체의 다형성을 구현할 수 있다.
- 상속 대상의 제한
부모 클래스의 private 접근을 갖는 필드와 메소드는 제외된다.
부모 클래스가 다른 패키지에 있을 경우, default 접근을 갖는 필드와 메소드도 제한된다.
(public 접근 제한자로 선언된 필드와 메소드만 접근 가능!)

- extends 키워드 : 자식 클래스가 상속할 부모 클래스를 지정하는 키워드.
public class A{
  int field1;
  void method1(){...}
}
public class B extends A { // A를 상속
  String field2;
  void method2(){...}
}
- 자바는 다중 상속을 허용하지 않기 떄문에, 부모 클래스 2개 이상 나열 불가.

3절. 부모 생성자 호출(super(...))
- 자식 객체를 생성할 때는 부모 객체부터 생성되고, 자식 객체가 다음에 생성된다.
- 부모 생성자가 호출 완료되고, 자식 생성자가 나중에 호출 완료된다.
ex)
DmbCellphone dmbCellPhone = new DmbCellPhone();
public DmbCellPhone(){
  super(); // 부모 생성자가 먼저 호출됨. 직접 작성하지 않아도 컴파일러가 자동으로 적용.
} // 부모 생성자 호출을 먼저 끝내고, 자식 생성자 호출이 끝남.

- 명시적으로 부모 생성자 호출
부모 객체를 생성할 떄, 부모 생성자를 선택해서 호출할 수 있따.
자식클래스{매개변수선언, ...){
  super( 매개값, ...);
  ...
}
super(매개값, ...)은 매개값과 동일한 타입,개수,순서가 맞는 부모 생성자를 호출한다.
만약 부모 생성자가 없다면 컴파일 오류가 발생한다.
반드시 자식 생성자의 첫줄에 위치해야 한다.
부모 클래스에 기본(매개변수 없는) 생성자가 없다면 필수적으로 작성해야 한다.

-

4절. 메소드 재정의(Override)
부모 클래스의 상속 메소드를 수정해서 자식 클래스에서 재정의하는 것을 말한다.
메소드 재정의 조건
- 부모 클래스의 메소드 선언부와 동일해야 한다.
- 접근 제한을 더 강하게 오버라이딩할 수 없다.
  public을 default나 private으로 수정 불가.
  default는 public으로 수정 가능.
- 새로운 예외(Exception)을 throws할 수 없다.
- 이클립스에서 [ctrl] + [spacebar] 누르면 상속 가능한 목록이 나온다.

@Override 어노테이션
컴파일러에게 부모 클래스의 메소드와 선언부가 동일한지 검사하도록 지시한다.
정확한 메소드 재정의를 위해 붙여 주는 것이 좋다.
public class Computer extends Calculator {
  @Override
  double areaCircle(double r) {
    System.out.println("Computer 객체의 arearCircle() 실행");
    return Math.PI * r * r;
  }
}

메소드 재정의 효과
- 부모 메소드는 숨겨지는 효과 발생(재정의된 자식 메소드가 실행)
자식 클래스에서 오버라이드된 메소드를 자식 객체에서 호출하면,
부모 객체의 메소드가 아닌, 자식 객체 메소드가 실행 됨.
부모에 method1(), method2() 선언, 자식에 method2(), method3() 재정의 되어있다면,
자식 객체에서 method1() 실행시 부모 메소드 실행, method2()/method3() 실행시 자식 메소드가 실행된다.

부모 메소드 사용(super)
메소드 재정의는 부모 메소드를 숨기는 효과
자식 클래스에서 수정되기 전의 부모 메소드를 호출하고자 할 경우, super를 사용.
ex) 자식 객체에서,
method2(); // 자식 클래스에서 재정의된 super2() 메소드를 호출.
super.method2(); // 부모 클래스에서 정의된 super2() 메소드를 호출.
cf) this.method2(); // 자신의 객체를 참조

5절. final 클래스와 final 메소드
final 키워드의 용도
- final 필드 : 수정할 수 없는 필드
- final 클래스 : 부모로 사용할 수 없는 클래스
- final 메소드 : 자식이 재정의할 수 없는 메소드
상속할 수 없는 final 클래스
- 자식 클래스를 만들지 못하도록 final 크래스로 선언.
오버라이딩할 수 없는 final 메소드
- 자식 클래스가 재정의 못하도록 부모 클래스의 메소드를 final로 만듦.

6절. protected 접근 제한자
상속과 관련된 접근 제한자. 필드와 메소드에만 붙일 수 있음(클래스에 X)
- 같은 패키지 : 모든 클래스에서 가능.
- 다른 패키지 : 자식 클래스만 접근 허용

7절. 타입변환과 다형성(polymorphism)
: 같은 타입이지만 실행 결과가 다양한 객체를 대입(이용)할 수 있는 성질을 말한다.
- 부모 타입에는 모든 자식 객체가 대입될 수 있다.
  (자식 타입은 부모 타입으로 자동 타입 변환된다.)
- 효과 : 객체를 부품화할 수 있다.
클래스 A의 자식 클래스 B, C가 있을 때 ->
A a = new B();
A a = new C();
Animal의 자식 Cat과 Dog ->
Animal a = new Cat();
Animal a = new Dog();
Tire t1 = new KoreaTire();
Tire t2 = new KeumhoTire();
자동차는 타이어 타입으로 한국 타이어와 금호 타이어를 사용하지만, 
각 타이어의 성능은 다르게 나온다. (다형성)

- 자동 타입 변환(Promotion)
프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다.
[부모클래스] [변수] = [자식클래스 타입]; (자동 타입 변환) 
Cat cat = new Cat();
Animal animal = cat; // cat 객체가 animal 타입으로 변환되어 대입됨.
cat == animal // true -> 힙 영역의 같은 부모 객체 Cat을 가리킴.
- 상속 계층에서 어떤 상위 타입이라도 자동 타입이 일어날 수 있다.

- 자동 타입 변환된 이후의 효과
부모 클래스에 선언된 필드와 메소드만 접근 가능한다.
★메소드가 재정의되었다면 자식 클래스의 재정의된 메소드가 호출된다. (다형성과 관련)

필드의 다형성
- 다형성을 구현하는 기술적 방법
 부모 타입으로 자동 변환
 재정의된 메소드(오버라이딩)
Car myCar = new Car();
myCar.frontRightTire = new HankookTire();
myCar.backLeftTire = new KumhoTIre();
myCar.run();
-
void run(){
  frontRighTire.roll(); // HankookTIre 클래스에서 재정의된 roll 메소드를 실행.
  backLeftTire.roll(); // KumhoTire 클래스에서 재정의된 roll 메소드를 실행.


- 하나의 배열로 객체 관리
class Car {
  Tire[] tires = {
    new Tire("앞왼쪽", 6);
    new Tire("앞오른쪽", 2);
    new Tire("뒤왼쪽", 3);
    new Tire("뒤오른쪽", 4);
  };
}
tires[1] = new KumhoTire("앞오른쪽", 13);

- 매개변수의 다형성
* 매개변수가 클래스 타입일 경우
 : 해당 클래스의 객체를 대입하는 것이 원칙이나, 자식 객체를 대입하는 것도 허용된다.  

Driver driver = new Driver();
Bus bus = new Bus();
driver.drive(bus); // drive() 메소드 실행

void drive(Vehicle vehicle){ // bus클래스를 매개변수로 인식.
  vehicle.run(); // 자식 객체가 재정의한 run() 메소드 실행 -> bus.run();

- 강제 타입 변환(Casting)
 부모 타입을 자식 타입으로 변환하는 것을 말한다.
 자식 클래스 변수 = (자식클래스) 부모클래스타입; // 캐스팅 기호 ( ) 사용하여 강제 타입 변환
* 조건!
 자식 타입이 부모 타입으로 자동 변환된 이후,
 다시 자식 타입으로 변환할 때만 유효하다.
ex)
A a = new B();
B b = a; // 컴파일 오류
B b = (B) a; // 실행 가능. A a = new A();로 a가 선언되었다면 컴파일 오류.

- 강제 타입 변환이 필요한 경우 :
 자식 타입이 부모 타입으로 자동 변환되면, 부모 타입에 선언된 필드와 메소드만 사용 가능하므로, 자식 타입에 선언된 필드와 메소드를 다시 사용하려면 강제 타입 변환이 필요함.

- 객체 타입 변환(instanceof)
 * 부모 타입이면 모두 자식 타입으로 강제 타입 변환할 수 있는 것은 아니다.
 (ClassCastException 예외가 발생할 수도 있다.)
Parent parent = new Parent();
Child child = (Child) parent; // 애초에 Parent 클래스 타입으로 생성된 인스턴스이므로 자식인 Child 클래스 타입으로 강제 타입 변환을 할 수 없다.
 * 먼저 자식 타입인지 확인 후 강제 타입을 해야 한다.
-> boolean result = 좌향(객체) instanceof 우향(타입) // 좌향 변수가 참조하는 객체가 우향 클래스 타입으로 생성된지 여부 확인.
ex)
if(parent instanceof Child) { // parent변수가 참조하는 객체가 Child타입으로 생성된 객체인지 확인
  Child child = (Child) parent;
}

8. 추상 클래스
- 추상(abstract) : 실체들 간에 공통되는 특성을 추출한 것을 말한다.
ex) 새,곤충,물고기 -> 동물(추상) / 삼성,현대,LG -> 회사(추상)
- 추상 클래스(abstract class)
 실체 클래스들의 공통되는 필드와 메소드를 정의한 클래스를 말한다.
 cf) 실체 클래스 : 객체를 만들어 사용할 수 있는 클래스
 추상 클래스는 실체 클래스의 부모 클래스 역할을 할 수 있다.
 추상 클래스는 단독으로 객체 생성을 할 수 없고, 부모 클래스로만 사용된다.
 public abstract class Animal();
 Animal animal = new Animal();(X)
 class Dog extends Anmail { ... }
- 추상 클래스의 용도
 실체 클래스의 공통된 필드와 메소드의 이름을 통일할 목적.
 실체 클래스를 작성할 때 시간을 절약(실체 클래스는 추가적인 필드와 메소드만 선언하면 됨).
- 실체 클래스 설계 규격을 만들고자 할 때
 실체 클래스가 가져야 할 필드와 메소드를 추상 클래스에 미리 정의해놓고, 
 실체 클래스는 추상 클래스를 무조건 상속받아 작성하도록 할 경우.

- 추상 메소드와 오버라이딩(재정의)
 메소드 이름은 동일하나, 실행 내용이 실체 클래스마다 다른 메소드가 있을 수 있다.
 구현 방법 :
 1) 추상 클래스에는 메소드의 선언부만 작성한다(추상 메소드). 
  -> 추상 메소드에서만 몸체(body, {}) 없이 메소드 선언이 가능하다.
  -> 추상 클래스에서만 추상 메소드 선언이 가능하다.
 2) 실체 클래스에서 메소드의 실행 내용을 작성한다(오버라이딩).
 



